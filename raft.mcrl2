sort State = struct follower | leader | candidate;
%TODO, Check if mType is neeeded or not  
sort mType = struct RequestVoteRequest;

% Global variable for number of nodes  
map  N, BATCH_SIZE: Nat;
eqn  N = 2;
	BATCH_SIZE = 1; 

% Define the push funtion for list 
map push:  Nat # List(Nat) -> List(Nat);

%Variable that maps the the id of Node to boolean. 
%If it maps to true then that node is already voted for the node that contains the voterlog
sort voterLog = List(Nat);    

map logTerm: List(Nat) # Int -> Nat;

var  l: List(Nat);
     x: Int;

eqn	(x < 1) -> logTerm(l, x) = 0;
	(x > #l) -> logTerm(l, x) = 0;
	(x >= 1 && x <= #l) -> logTerm(l,x) = l . abs(x-1);   

map initList: Nat # Nat # Nat -> List(Nat);   

var size, v, c: Nat; 

eqn (c >= size) -> initList(size, v, c) = []; 
	(c < size) -> initList(size, v, c) = v |> initList(size, v, c+1);

map slice: List(Nat) # Int # Int -> List(Nat);  
	growSlice: List(Nat) # List(Nat) # Int # Int # Int -> List(Nat); 

var a, b: List(Nat);
	x, y, n: Int; 	
 
eqn slice(a, x, y) = growSlice([], a, x, y, 0);
	n < x -> growSlice(b, a, x, y, n) = growSlice(b, a, x, y, n + 1);
	n >= y -> growSlice(b, a, x, y, n) = b;
	(n >= x && n < y) -> growSlice(b, a, x, y, n) = growSlice(b <| a.abs(n), a, x, y, n + 1);

map replace: List(Nat) # Nat # Nat -> List(Nat);  

var a: List(Nat);
	i: Nat; 
	x: Nat; 

eqn (a . i != x) -> replace(a, i, x) = slice(a, 0, i) ++ [x] ++ slice(a, i+1, #a);
	(a . i == x) -> replace(a, i, x) = a;

act
  	sendClientRequest, wlog, receiveClientRequest: Nat;
	stop, timeout, becomeLeader, AddVoteToItself, stepDown, test, testHandle;  
	% param1: type of vote request 
	% param2: current term
	% param3: last log term 
	% param4: last log index
	% param5: source or destination 
	% param6: source or destination
	requestVote, handleRequestVoteRequest, requestVoteSent: mType # Nat # Nat # Nat # Nat # Nat;
	sendReply, handleRequestVoteReply, replyVoteSent: Nat # Bool # Nat # Nat; 
%(term, prevIndex, prevTerm, entries, commitIndex, from, to)
	%param 1: current term of the source 
	%param 2: prevIndex 
	%param 3: prevTerm 
	%param 4: entries 
	%param 5: commitIndex 
	%param 5: source or destination 
	%param 6: source or destination  
	sendAppendEntriesRequest,handleAppendEntriesRequest, appendEntriesRequestSent: Nat # Int # Nat # List(Nat) # Int # Nat # Nat; 
	%param 1: current term of the desitnation 
	%param 2: sucess or not (true is succes, otherwise not)
	%param 3: matchIndex  
	%param 4: current term
	%param 5: prevIndex 
	%param 6: prevTerm 
	%param 7: entries 
	%param 8: commitIndex 
	%param 9: source or destination 
	%param 10: source or destination
	sendAppendEntriesReply, handleAppendEntriesReply, appendEntriesRequestReplied: Nat # Bool # Nat # Nat # Int # Nat # List(Nat) # Int # Nat # Nat; 


proc
	% Client uses list to sendClientRequest messages to a leader node.    
	Client(num: Nat) = (num >= 1) -> sendClientRequest(num) .  Client(num = abs(num-1));
	
	% Node process 
	% id is the id of a node
	% state: state of the node define by sorted State. There are three states of a node: leader, follower, and candidate  
	% l: List is that contains the log of the node. (Temrn and index)
	% term of Node  
	% Votedfor if it does not vote for anyone, it is 0, otherwise the index of the voted node
 	Node(id: Nat, state: State, l: List(Nat), voterLog: voterLog, term: Nat, votedFor: Nat, nextIndex: List(Nat), matchIndex: List(Nat), commitIndex: Nat) = 
	(term < 15) -> (
		% If node is a leader, then the client can sendClientRequest message to that node  
		((state == leader) -> (sum v:Nat . receiveClientRequest(v). Node(l = l ++ [term])))

		% The node can stop anytime, if it stops then, it can startup as the follower with log and term unchanged
		%+ stop . Node(id, follower, l, term)

		% if it time out, then it changes to the candidate state and term + 1 (Timeout here means that we start the the new election )
		+ (state == follower || state == candidate) -> timeout . Node(state = candidate, term = term+1, votedFor = id, voterLog = [id], matchIndex = initList(N, 0, 0), nextIndex = initList(N, 1, 0))
		%TODO,: I forget about the term for now 

		% If it is a candiate then it sends the request vote request. 
		% For now, I assume that the vote request is always true, and the term and log is 1  
		% TODO deltet the requestVoterRequest
		+ (state == candidate) -> (    
			sum d: Nat . (!(d in voterLog)) -> requestVote(RequestVoteRequest, term, logTerm(l, #l), #l, id, d). Node()
			+ 	
			% If d is not in the voterlog, add d in the voter log 
			sum d: Nat . (!(d in voterLog)) -> (handleRequestVoteReply(term, true, id, d). Node(voterLog = voterLog <| d) 
				+ 
				handleRequestVoteReply(term, false, id, d). Node())
			+ 
			% Why do I need to limit the voter log I need to clean the vote in some way  
			((#voterLog*2 > N)) -> becomeLeader . Node(state = leader, nextIndex = initList(N, #l+1, 0))) 

	% Any node can handle the Vote Reqeust. 1 %Todo delete candidate for the vote request becaues all node can handle this
	+ (state != candidate) -> (
		% For the reply, it does not change the state of the node? 
		sum d, lastlogterm, requestTerm: Nat . sum lastlogindex: Nat . handleRequestVoteRequest(RequestVoteRequest, requestTerm, lastlogterm, lastlogindex,d,id) .
		(term < requestTerm) -> stepDown . Node(term = requestTerm, state = follower, votedFor = 0) 
							<> 
							(term == requestTerm && 
							(votedFor == 0 || votedFor == requestTerm) 
								&& (lastlogterm > logTerm(l, #l) || (lastlogterm == logTerm(l, #l) && lastlogindex >= #l))) %TOODO change this to log term 
									-> sendReply(term, true,d ,id).Node(votedFor = d) 
									<> sendReply(term, false, d, id) . Node())  
		
	+ sum peer: Nat . (peer != id && peer < N && state == leader && nextIndex . peer <= #l) -> (test . (matchIndex . peer +1 < nextIndex . peer) 
		-> 
		sendAppendEntriesRequest(term, nextIndex . peer - 1, logTerm(l,  (nextIndex . peer) - 1), slice(l, nextIndex . peer - 1, nextIndex . peer - 1), min(commitIndex, nextIndex . peer - 1), id, peer)
		<> 
		sendAppendEntriesRequest(term, nextIndex . peer - 1, logTerm(l,  (nextIndex . peer) - 1), slice(l, nextIndex . peer - 1, min((nextIndex . peer) - 1 + BATCH_SIZE, #l)), min(commitIndex, (nextIndex . peer) - 1 + BATCH_SIZE), id, peer)
		) . Node()

	+ sum requestTerm: Nat, requestPreIndex: Int, requestPreTerm: Nat, requestEntires: List(Nat), requestCommitIndex: Int, from: Nat. 
		handleAppendEntriesRequest(requestTerm, requestPreIndex, requestPreTerm, requestEntires, requestCommitIndex, from, id) . testHandle
		. 
		(term < requestTerm) -> (stepDown . Node(term = requestTerm, state = follower, votedFor = 0)) 
		<> 
		((term == requestTerm && (requestPreIndex == 0 || requestPreIndex <= #l && logTerm(l, requestPreIndex) ==  requestPreTerm)) 	
			-> sendAppendEntriesReply(term, true, abs(requestPreIndex) + #requestEntires, requestTerm, requestPreIndex, requestPreTerm, requestEntires, requestCommitIndex, from, id) . Node(l = slice(l, 0, abs(requestPreIndex)) ++ requestEntires, state = follower)
			<> sendAppendEntriesReply(term, false, 0, requestTerm, requestPreIndex, requestPreTerm, requestEntires, requestCommitIndex, from, id)).Node()

	+ sum replyTerm: Nat, success: Bool, replyMatchIndex: Nat, requestTerm: Nat, requestPreIndex: Int, requestPreTerm: Nat, requestEntires: List(Nat), requestCommitIndex: Int, from: Nat, to: Nat . 
		handleAppendEntriesReply(replyTerm, success, replyMatchIndex, requestTerm, requestPreIndex, requestPreTerm, requestEntires, requestCommitIndex, from, to) 
		. (term < replyTerm) ->  stepDown . Node(term = replyTerm, state = follower, votedFor = 0) 
							 <> ((state == leader && term == replyTerm)  -> ((success == true) -> test . Node(matchIndex = replace(matchIndex, to, max(matchIndex . to, replyMatchIndex)), nextIndex = replace(nextIndex, to, replyMatchIndex + 1))
																							<>  test . Node(nextIndex = replace(nextIndex, to, max(1, nextIndex . to - 1))))) %ToDo, I need to test this.
	
	);      


%Should I put step down in the allow node
init
  allow(
    { stop, timeout, becomeLeader, requestVoteSent, replyVoteSent, AddVoteToItself, stepDown, wlog, test, appendEntriesRequestSent, appendEntriesRequestReplied, sendAppendEntriesRequest, testHandle, sendAppendEntriesReply},
    comm(
      	{sendClientRequest|receiveClientRequest -> wlog,
		requestVote|handleRequestVoteRequest -> requestVoteSent,
		sendReply|handleRequestVoteReply -> replyVoteSent,
		sendAppendEntriesRequest | handleAppendEntriesRequest -> appendEntriesRequestSent,
		sendAppendEntriesReply | handleAppendEntriesReply -> appendEntriesRequestReplied}, 
	% I chose term to start with 1, but it can also start with 0 
	% Remeber to change N - N is the number of node
	% To do make the function to initiliaze the index haha  
      Client(4) || Node(0, follower, [], [], 1, 0, initList(N, 1, 0), initList(N, 0, 0), 0) || Node(1, follower, [], [], 1, 0, initList(N, 1, 0), initList(N, 0, 0), 0)
  ) ) ;
