sort State = struct follower | leader | candidate;
%TODO, Check if mType is neeeded or not  
sort mType = struct RequestVoteRequest;

% Global variable for number of nodes  
map  N: Pos;
eqn  N = 2;

% Define the push funtion for list 
map push:  Pos # List(Pos) -> List(Pos);

var  l: List(Pos);
     x: Pos;

eqn  push(x,l) = x |> l;  

%Variable that maps the the id of Node to boolean. 
%If it maps to true then that node is already voted for the node that contains the voterlog
sort voterLog = List(Pos);    
	


act
  	send, wlog, receive:Pos # Pos;
	stop, timeout, becomeLeader, AddVoteToItself;  
	requestVote, handleRequestVoteRequest, requestVoteSent: mType # Pos # Pos # Pos # Pos;
	sendReply, handleRequestVoteReply, replyVoteSent: Pos # Bool # Pos # Pos; 

proc
	% Client uses list to send messages to a leader node.    
	Client(l: List(Pos)) = (#l >= 1) -> sum p:Pos . send(p, rhead(l)) .  Client(rtail(l));
	
	% Node process 
	% id is the id of a node
	% state: state of the node define by sorted State. There are three states of a node: leader, follower, and candidate  
	% l: List is that contains the log of the node. (Temrn and index)
 	Node(id: Pos, state: State, l: List(Pos), voterLog: voterLog) = 

		% If node is a leader, then the client can send message to that node  
		((state == leader) -> (sum v:Pos . receive(id, v). Node(l = push(1, l))))

		% The node can stop anytime, if it stops then, it can startup as the follower with log and term unchanged
		%+ stop . Node(id, follower, l, term)

		% if it time out, then it changes to the candidate state and term + 1
		+ timeout . Node(state = candidate)
		%TODO,: I forget about the term for now 

		% If it is a candiate then it sends the request vote request. 
		% For now, I assume that the vote request is always true, and the term and log is 1  
		+ (state == candidate) -> (    
		% The node vote for itself  
			(!(id in voterLog)) -> AddVoteToItself . Node(voterLog = voterLog <| id) 
		% If d is not in the voterlog, the candidate request vote. 
			+
			sum d: Pos . (!(d in voterLog)) -> requestVote(RequestVoteRequest, 1, 1, id, d). Node()
			+ 	
			% If d is not in the voterlog, add d in the voter log 
			sum d: Pos . (!(d in voterLog)) -> handleRequestVoteReply(1, true, id, d). Node(voterLog = voterLog <| d)
			+ 
			% Why do I need to limit the voter log I need to clean the vote in some way  
			% TODO check voterlog it can bot be greate than 10  
			((#voterLog*2 > N)) -> becomeLeader . Node(state = leader))

	% Any node can handle the Vote Reqeust. 1
	+ (state != candidate) -> (
		% For the reply, it does not change the state of the node? 
		sum d: Pos . handleRequestVoteRequest(RequestVoteRequest, 1,1,d,id) . sendReply(1, true,d ,id) . Node());       

init
  allow(
    { stop, timeout, becomeLeader, requestVoteSent, replyVoteSent, AddVoteToItself},
    comm(
      	{send|receive -> wlog,
		requestVote|handleRequestVoteRequest -> requestVoteSent,
		sendReply|handleRequestVoteReply -> replyVoteSent}, 
	% I chose term to start with 1, but it can also start with 0 
	% Remeber to change N - N is the number of node
      Client([1,2]) || Node(1, leader, [], []) || Node(2, follower, [], [])
  ) ) ;
